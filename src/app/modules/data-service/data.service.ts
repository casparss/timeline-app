import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { remove } from 'lodash';
import { BehaviorSubject } from "rxjs";
import { Subject, Observable } from 'rxjs';
import { activityInterface, channelInterface } from './data.interface';
import * as moment from 'moment';

@Injectable()
export class DataSvc {

  public channelsSubject$ = <any>new Subject();
  public channels$: Observable<any>;
  private channelsLastValue;

  constructor(private http: Http){
    this.channels$ = this.configureChannels$();
  }

  /**
   * @description configureChannels$ configure channels sets up the central observable for the
   * channels data. Every time an update is made to any of the channels data, then
   * the channel observable is notified with the change and all subscribers of the
   * channels observable are updated. This means that all applicattion state is
   * centralised and changes to the state will update components and views that
   * are hooked in
   * @return {Observable}
   */

  private configureChannels$(){
    return this.channelsSubject$.asObservable()
      .do(channels => this.channelsLastValue = channels)
      .map(channels => {
        channels.forEach(({ activities }) => {
          activities.forEach(({ period }) => {
            period.from = moment(period.from);
            period.to = moment(period.to);
          });
        });
        return channels;
      });
  }

  /**
   * @description fetch calls the main endpoint to retrieve all channels in the db
   * @return {Observable}
   */

  fetch(){
    return this.http.get('/api/channels')
      .map(res => res.json())
      .do(channels => this.channelsSubject$.next(channels));
  }

  /**
   * @description addChannel does what is says on the tin, adds a new channel by posting to
   * the channel endpoint, the db persists the new channel and the returns back
   * the channel object with the Mongo ObjectId, which is then added to the current
   * channels array and then pushed to ChannelsSubject which notifies all subscribers
   * of Channels observables]
   * @param  {string} channelTitle [desired channel title or name]
   * @return {Observable}
   */

  addChannel(channelTitle: string){
    let newChannel = {
      name: channelTitle,
      activities: []
    };

    return this.http.post('/api/channel', newChannel)
      .map(res => res.json())
      .do(channel => {
        this.pushNewChanges(channels => {
          channels.push(channel);
          return channels;
        });
      });
  }

  /**
   * @description removes a channel, works in more or less the same way as addChannel,
   * but instead removes object for the db
   * @param  {string} channelId
   * @return {Observable}
   */

  removeChannel(channelId: string){
    return this.http.delete(`/api/channel/${channelId}`)
      .do(() => this.pushNewChanges(
        channels => {
          remove(channels, channel => channel._id === channelId);
          return channels;
        }
      ));
  }

  /**
   * @description handleUploadResponse is for handling the response of the file
   * uploader. It parses the response string into JSON and pushes the changes
   * @param  {string} res [description]
   */

  handleUploadResponse(res){
    this.pushNewChanges(channels => {
      channels.push(JSON.parse(res));
      return channels;
    });
  }

  /**
   * @description updateActivity is called when the user has updated the activity details
   * @param  {Object} activityForm form object generated by reactive form
   * @param  {string} channelId
   * @param  {string} activityId
   */

  updateActivity({ activityForm, channelId, activityId }){
    let uri = `/api/channel/${channelId}/acitvity/${activityId}`;
    return this.http.post(uri, activityForm);
  }

  /**
   * @description pushNewChanges is a convenience method which grabs the latest
   * channels state mutates it and then calls next on the Channals Subject to update
   * application state.
   * @param  {[function]} mutator - this is a function that is supposed to change and
   * return the newly changed data so it can update the application state
   */

  pushNewChanges(mutator){
    let channelsCopy = Object.assign([], this.channelsLastValue);
    this.channelsSubject$.next(mutator(channelsCopy));
  }

}
